"""Tests for ImageFolder support.

Tests SlipstreamImageFolder, open_imagefolder, and dataset type detection.
"""

import tempfile
from pathlib import Path

import pytest


class TestSlipstreamImageFolder:
    """Tests for SlipstreamImageFolder class."""

    @pytest.fixture
    def temp_imagefolder(self, tmp_path):
        """Create a temporary ImageFolder structure with test images."""
        # Create class directories
        class1_dir = tmp_path / "class_a"
        class2_dir = tmp_path / "class_b"
        class1_dir.mkdir()
        class2_dir.mkdir()

        # Create minimal JPEG images (smallest valid JPEG)
        # This is a 1x1 red pixel JPEG
        minimal_jpeg = bytes([
            0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
            0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
            0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
            0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
            0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
            0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
            0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
            0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
            0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00,
            0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03,
            0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
            0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06,
            0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
            0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,
            0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
            0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
            0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75,
            0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
            0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
            0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
            0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9,
            0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
            0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4,
            0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
            0x00, 0x00, 0x3F, 0x00, 0xFB, 0xD5, 0xDB, 0x20, 0xA8, 0xF1, 0x7E, 0xAA,
            0x7C, 0xBA, 0x77, 0xFF, 0xD9
        ])

        # Create PNG image (8x8 red pixel)
        # Minimal PNG header + IHDR + IDAT + IEND
        minimal_png = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,  # PNG signature
            0x00, 0x00, 0x00, 0x0D,  # IHDR length
            0x49, 0x48, 0x44, 0x52,  # IHDR
            0x00, 0x00, 0x00, 0x08,  # width = 8
            0x00, 0x00, 0x00, 0x08,  # height = 8
            0x08, 0x02,              # bit depth = 8, color type = 2 (RGB)
            0x00, 0x00, 0x00,        # compression, filter, interlace
            0x4B, 0x6D, 0x29, 0x39,  # CRC
            0x00, 0x00, 0x00, 0x1D,  # IDAT length
            0x49, 0x44, 0x41, 0x54,  # IDAT
            0x08, 0xD7, 0x63, 0xF8, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x05, 0xFE, 0x02,
            0xFE, 0xDC, 0xCC, 0x59, 0xE7, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00,
            0xFF, 0xFF, 0xFF, 0xFF,  # CRC (placeholder)
            0x00, 0x00, 0x00, 0x00,  # IEND length
            0x49, 0x45, 0x4E, 0x44,  # IEND
            0xAE, 0x42, 0x60, 0x82   # CRC
        ])

        # Write images
        (class1_dir / "img1.jpg").write_bytes(minimal_jpeg)
        (class1_dir / "img2.jpg").write_bytes(minimal_jpeg)
        (class2_dir / "img3.jpg").write_bytes(minimal_jpeg)
        (class2_dir / "img4.png").write_bytes(minimal_png)

        return tmp_path

    def test_basic_creation(self, temp_imagefolder):
        """Test basic SlipstreamImageFolder creation."""
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamImageFolder(temp_imagefolder)

        assert len(dataset) == 4
        assert len(dataset.classes) == 2
        assert "class_a" in dataset.classes
        assert "class_b" in dataset.classes

    def test_sample_structure(self, temp_imagefolder):
        """Test that samples have correct dict structure."""
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamImageFolder(temp_imagefolder)
        sample = dataset[0]

        assert isinstance(sample, dict)
        assert set(sample.keys()) == {"image", "label", "index", "path"}
        assert isinstance(sample["image"], bytes)
        assert isinstance(sample["label"], int)
        assert sample["index"] == 0
        assert isinstance(sample["path"], str)

    def test_field_types(self, temp_imagefolder):
        """Test field_types property."""
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamImageFolder(temp_imagefolder)

        assert dataset.field_types == {
            "image": "ImageBytes",
            "label": "int",
            "index": "int",
            "path": "str",
        }

    def test_cache_path_default(self, temp_imagefolder):
        """Test default cache_path uses unified ~/.slipstream/ base."""
        from slipstream.readers import SlipstreamImageFolder
        from slipstream.utils.cache_dir import get_cache_base

        dataset = SlipstreamImageFolder(temp_imagefolder)

        # Default cache base is ~/.slipstream/ (or SLIPSTREAM_CACHE_DIR env var)
        expected_base = get_cache_base()
        # cache_path should be versioned: {base}/slipcache-{hash}/
        assert dataset.cache_path.parent == expected_base
        assert dataset.cache_path.name.startswith("slipcache-")

    def test_cache_path_custom(self, temp_imagefolder, tmp_path):
        """Test custom cache_path uses versioned subdir."""
        from slipstream.readers import SlipstreamImageFolder

        custom_cache = tmp_path / "my-cache"
        dataset = SlipstreamImageFolder(temp_imagefolder, cache_dir=custom_cache)

        # cache_path should be versioned: {custom}/slipcache-{hash}/
        assert dataset.cache_path.parent == custom_cache
        assert dataset.cache_path.name.startswith("slipcache-")

    def test_image_bytes_valid(self, temp_imagefolder):
        """Test that image bytes are valid JPEG/PNG."""
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamImageFolder(temp_imagefolder)

        for i in range(len(dataset)):
            sample = dataset[i]
            # Check JPEG or PNG magic bytes
            assert sample["image"][:2] in (b"\xff\xd8", b"\x89P")

    def test_repr(self, temp_imagefolder):
        """Test string representation."""
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamImageFolder(temp_imagefolder)
        repr_str = repr(dataset)

        assert "SlipstreamImageFolder" in repr_str
        assert "num_samples=4" in repr_str
        assert "num_classes=2" in repr_str


class TestOpenImageFolder:
    """Tests for open_imagefolder function."""

    @pytest.fixture
    def temp_imagefolder(self, tmp_path):
        """Create a temporary ImageFolder structure."""
        class1_dir = tmp_path / "class_a"
        class1_dir.mkdir()

        # Minimal JPEG
        minimal_jpeg = bytes([
            0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
            0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
            0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
            0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
            0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
            0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
            0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
            0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
            0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00,
            0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03,
            0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
            0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06,
            0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
            0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,
            0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
            0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
            0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75,
            0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
            0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
            0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
            0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9,
            0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
            0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4,
            0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
            0x00, 0x00, 0x3F, 0x00, 0xFB, 0xD5, 0xDB, 0x20, 0xA8, 0xF1, 0x7E, 0xAA,
            0x7C, 0xBA, 0x77, 0xFF, 0xD9
        ])

        (class1_dir / "img.jpg").write_bytes(minimal_jpeg)
        return tmp_path

    def test_local_path(self, temp_imagefolder):
        """Test opening a local ImageFolder."""
        from slipstream.readers import open_imagefolder

        dataset = open_imagefolder(temp_imagefolder, verbose=False)

        assert len(dataset) == 1
        assert isinstance(dataset[0], dict)

    def test_nonexistent_path(self, tmp_path):
        """Test error on non-existent path."""
        from slipstream.readers import open_imagefolder

        with pytest.raises(FileNotFoundError):
            open_imagefolder(tmp_path / "nonexistent", verbose=False)

    def test_invalid_imagefolder(self, tmp_path):
        """Test error on directory without ImageFolder structure."""
        from slipstream.readers import open_imagefolder

        # Create empty directory
        empty_dir = tmp_path / "empty"
        empty_dir.mkdir()

        with pytest.raises(ValueError, match="Not a valid ImageFolder"):
            open_imagefolder(empty_dir, verbose=False)


class TestDatasetTypeDetection:
    """Tests for dataset type auto-detection."""

    def test_detect_imagefolder(self, tmp_path):
        """Test detection of ImageFolder structure."""
        from slipstream.dataset import detect_local_dataset_type

        # Create ImageFolder structure
        class_dir = tmp_path / "class_a"
        class_dir.mkdir()
        (class_dir / "img.jpg").write_bytes(b"\xff\xd8\xff")

        result = detect_local_dataset_type(tmp_path)
        assert result == "imagefolder"

    def test_detect_streaming(self, tmp_path):
        """Test detection of streaming dataset (LitData)."""
        import json

        from slipstream.dataset import detect_local_dataset_type

        # Create index.json with LitData structure
        index = {"config": {"data_format": "litdata_v1"}}
        (tmp_path / "index.json").write_text(json.dumps(index))

        result = detect_local_dataset_type(tmp_path)
        assert result == "streaming"

    def test_detect_huggingface(self, tmp_path):
        """Test detection of HuggingFace dataset."""
        import json

        from slipstream.dataset import detect_local_dataset_type

        # Create index.json with HuggingFace structure
        index = {"config": {"item_loader": "ParquetLoader"}}
        (tmp_path / "index.json").write_text(json.dumps(index))

        result = detect_local_dataset_type(tmp_path)
        assert result == "huggingface"

    def test_detect_unknown(self, tmp_path):
        """Test detection of unknown structure."""
        from slipstream.dataset import detect_local_dataset_type

        # Empty directory
        result = detect_local_dataset_type(tmp_path)
        assert result == "unknown"

    def test_detect_nonexistent(self, tmp_path):
        """Test detection of non-existent path."""
        from slipstream.dataset import detect_local_dataset_type

        result = detect_local_dataset_type(tmp_path / "nonexistent")
        assert result == "unknown"


class TestIsImageFolderStructure:
    """Tests for is_imagefolder_structure function."""

    def test_valid_structure(self, tmp_path):
        """Test detection of valid ImageFolder."""
        from slipstream.dataset import is_imagefolder_structure

        class_dir = tmp_path / "class"
        class_dir.mkdir()
        (class_dir / "img.jpg").write_bytes(b"\xff\xd8\xff")

        assert is_imagefolder_structure(tmp_path) is True

    def test_no_subdirs(self, tmp_path):
        """Test directory without subdirs."""
        from slipstream.dataset import is_imagefolder_structure

        (tmp_path / "file.txt").write_text("hello")

        assert is_imagefolder_structure(tmp_path) is False

    def test_subdirs_without_images(self, tmp_path):
        """Test subdirs without image files."""
        from slipstream.dataset import is_imagefolder_structure

        subdir = tmp_path / "subdir"
        subdir.mkdir()
        (subdir / "data.txt").write_text("not an image")

        assert is_imagefolder_structure(tmp_path) is False

    def test_file_path(self, tmp_path):
        """Test with file path instead of directory."""
        from slipstream.dataset import is_imagefolder_structure

        file_path = tmp_path / "file.txt"
        file_path.write_text("hello")

        assert is_imagefolder_structure(file_path) is False


class TestImageHeaderParsing:
    """Tests for image header dimension parsing."""

    def test_jpeg_dimensions(self):
        """Test JPEG dimension parsing."""
        from slipstream.utils.image_header import read_image_dimensions

        # Create a valid JPEG (1x1 pixel)
        jpeg_bytes = bytes([
            0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
            0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
            0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
            0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
            0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
            0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
            0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
            0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
            0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3F, 0x00,
            0x7F, 0xFF, 0xD9
        ])

        width, height = read_image_dimensions(jpeg_bytes)
        assert width == 1
        assert height == 1

    def test_png_dimensions(self):
        """Test PNG dimension parsing."""
        from slipstream.utils.image_header import read_image_dimensions

        # Create minimal PNG (8x8)
        png_bytes = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,  # PNG signature
            0x00, 0x00, 0x00, 0x0D,  # IHDR length
            0x49, 0x48, 0x44, 0x52,  # IHDR
            0x00, 0x00, 0x00, 0x08,  # width = 8
            0x00, 0x00, 0x00, 0x10,  # height = 16
            0x08, 0x02,              # bit depth = 8, color type = 2 (RGB)
            0x00, 0x00, 0x00,        # compression, filter, interlace
            0x00, 0x00, 0x00, 0x00,  # CRC (placeholder)
        ])

        width, height = read_image_dimensions(png_bytes)
        assert width == 8
        assert height == 16


class TestSlipstreamDatasetAutoDetection:
    """Test that SlipstreamDataset auto-detects ImageFolder format."""

    @pytest.fixture
    def temp_imagefolder(self, tmp_path):
        """Create a temporary ImageFolder structure."""
        class1_dir = tmp_path / "class_a"
        class1_dir.mkdir()

        # Minimal JPEG
        minimal_jpeg = bytes([
            0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
            0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
            0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
            0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
            0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
            0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
            0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
            0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
            0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0x1F, 0x00, 0x00,
            0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x09, 0x0A, 0x0B, 0xFF, 0xC4, 0x00, 0xB5, 0x10, 0x00, 0x02, 0x01, 0x03,
            0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
            0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06,
            0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
            0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72,
            0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
            0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
            0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75,
            0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
            0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
            0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
            0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9,
            0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
            0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4,
            0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
            0x00, 0x00, 0x3F, 0x00, 0xFB, 0xD5, 0xDB, 0x20, 0xA8, 0xF1, 0x7E, 0xAA,
            0x7C, 0xBA, 0x77, 0xFF, 0xD9
        ])

        (class1_dir / "img.jpg").write_bytes(minimal_jpeg)
        return tmp_path

    def test_local_dir_returns_slipstream_dataset(self, temp_imagefolder):
        """Test that SlipstreamDataset(local_dir=...) returns SlipstreamDataset wrapping ImageFolder."""
        from slipstream import SlipstreamDataset
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamDataset(local_dir=str(temp_imagefolder), verbose=False)

        assert isinstance(dataset, SlipstreamDataset)
        assert isinstance(dataset._reader, SlipstreamImageFolder)
        assert len(dataset) == 1

    def test_input_dir_returns_slipstream_dataset(self, temp_imagefolder):
        """Test that SlipstreamDataset(input_dir=...) returns SlipstreamDataset wrapping ImageFolder."""
        from slipstream import SlipstreamDataset
        from slipstream.readers import SlipstreamImageFolder

        dataset = SlipstreamDataset(input_dir=str(temp_imagefolder), verbose=False)

        assert isinstance(dataset, SlipstreamDataset)
        assert isinstance(dataset._reader, SlipstreamImageFolder)

    def test_sample_has_correct_keys(self, temp_imagefolder):
        """Test that samples from auto-detected ImageFolder have correct keys."""
        from slipstream import SlipstreamDataset

        dataset = SlipstreamDataset(local_dir=str(temp_imagefolder), verbose=False)
        sample = dataset[0]

        assert set(sample.keys()) == {"image", "label", "index", "path"}
        assert isinstance(sample["image"], bytes)

    def test_decode_images_pil(self, temp_imagefolder):
        """Test that decode_images=True returns PIL Images."""
        from PIL import Image as PILImage

        from slipstream import SlipstreamDataset

        dataset = SlipstreamDataset(
            local_dir=str(temp_imagefolder),
            decode_images=True,
            to_pil=True,
            verbose=False,
        )
        sample = dataset[0]

        assert isinstance(sample["image"], PILImage.Image)

    def test_decode_images_tensor(self, temp_imagefolder):
        """Test that decode_images=True, to_pil=False returns tensors."""
        import torch

        from slipstream import SlipstreamDataset

        dataset = SlipstreamDataset(
            local_dir=str(temp_imagefolder),
            decode_images=True,
            to_pil=False,
            verbose=False,
        )
        sample = dataset[0]

        assert isinstance(sample["image"], torch.Tensor)
        assert sample["image"].dim() == 3  # CHW format


class TestTopLevelImports:
    """Test that new exports are accessible."""

    def test_imagefolder_imports(self):
        """Test SlipstreamImageFolder can be imported from top level."""
        from slipstream import SlipstreamImageFolder, open_imagefolder

        assert SlipstreamImageFolder is not None
        assert open_imagefolder is not None

    def test_readers_imports(self):
        """Test imports from readers module."""
        from slipstream.readers import SlipstreamImageFolder, open_imagefolder

        assert SlipstreamImageFolder is not None
        assert open_imagefolder is not None

    def test_dataset_detection_imports(self):
        """Test dataset detection functions are importable."""
        from slipstream.dataset import (
            detect_local_dataset_type,
            is_imagefolder_structure,
        )

        assert detect_local_dataset_type is not None
        assert is_imagefolder_structure is not None
